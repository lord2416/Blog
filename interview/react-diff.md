#节点复用条件
1.同一层级
2.组件类型相同
3.key相同

#reconcileChildrenArray
## step1
- 新老fiber都是从左开始遍历，按位比较，如果节点可以复用，那么都往后移一位，否则中止本轮循环
- olderFiber !== null 才会进入，因此初次渲染会跳过

## step2
- 如果newIndex === newChildren.length, 证明经过上轮for循环，新节点已经遍历完了，那么如果还有剩下的老节点，删除即可

## step3
- 如果老节点没了，新节点还有，那么新节点逐个新增即可
- 初次渲染走这里
- 如果满足此条件，step4和step5不会执行

## step4
- 新老节点都还有，最麻烦的地方，react diff的核心
- 经过上面的步骤，走到这里的新老节点都是乱序的，因此接下来遍历新的节点时，需要考虑的事情是如何去老节点链表找某个key对应的节点
- 因为老节点链表是单链表，查找的时间复杂度是O(n)，可以把老节点链表生一个Map，方便快速查找以及删除字典中的节点
  
## step5
- 经历过step4，发现老节点中还有没被复用的，全部删除即可

## 总结
1.新老VDOM从左开始遍历，按位置比较，即第i个orderFiber和第i个newFiber比较，如果可以复用先复用，然后新老节点都后移一位，否则中止本轮循环
2.如果经过step1，新节点已经遍历完了，还有剩余的老节点，那么删除剩余的老节点即可
3.如果经过step1，老节点已经遍历完了，还有新节点，那么逐个递增新节点即可。初次渲染会走这里。
4.走到这里，新老节点都还有，并且乱序。将oldFiber单链表记录为Map，即existingChildren，接下来遍历newChildren，找到能复用的fiber，就复用并从existingChildren中删除该fiber
5.经历step4，如果existingChildren还有未被复用的节点，全部删除即可